function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
import { csv, json, text, tsv } from "d3-request";
import fold from "./fold.js";
import concat from "./concat.js";
import isData from "./isData.js";
import { isObject } from "d3plus-common";

/**
  @function dataLoad
  @desc Loads data from a filepath or URL, converts it to a valid JSON object, and returns it to a callback function.
  @param {Array|String} path The path to the file or url to be loaded. Also support array of paths strings. If an Array of objects is passed, the xhr request logic is skipped.
  @param {Function} [formatter] An optional formatter function that is run on the loaded data.
  @param {String} [key] The key in the `this` context to save the resulting data to.
  @param {Function} [callback] A function that is called when the final data is loaded. It is passed 2 variables, any error present and the data loaded.
*/
export default function (path, formatter, key, callback) {
  var _this = this;
  var parser;
  var getParser = function getParser(path) {
    var ext = path.slice(path.length - 4);
    switch (ext) {
      case ".csv":
        return csv;
      case ".tsv":
        return tsv;
      case ".txt":
        return text;
      default:
        return json;
    }
  };
  var validateData = function validateData(err, parser, data) {
    if (parser !== json && !err && data && data instanceof Array) {
      data.forEach(function (d) {
        for (var k in d) {
          if (!isNaN(d[k])) d[k] = parseFloat(d[k]);else if (d[k].toLowerCase() === "false") d[k] = false;else if (d[k].toLowerCase() === "true") d[k] = true;else if (d[k].toLowerCase() === "null") d[k] = null;else if (d[k].toLowerCase() === "undefined") d[k] = undefined;
        }
      });
    }
    return data;
  };
  var loadedLength = function loadedLength(loadedArray) {
    return loadedArray.reduce(function (prev, current) {
      return current ? prev + 1 : prev;
    }, 0);
  };
  var getPathIndex = function getPathIndex(url, array) {
    return array.indexOf(url);
  };

  // If path param is a not an Array then convert path to a 1 element Array to re-use logic
  if (!(path instanceof Array)) path = [path];
  var needToLoad = path.find(isData);
  var loaded = new Array(path.length);
  var toLoad = [];

  // If there is a string I'm assuming is a Array to merge, urls or data
  if (needToLoad) {
    path.forEach(function (dataItem, ix) {
      if (isData(dataItem)) toLoad.push(dataItem);else loaded[ix] = dataItem;
    });
  }
  // Data array itself
  else {
    loaded[0] = path;
  }

  // Load all urls an combine them with data arrays
  var alreadyLoaded = loadedLength(loaded);
  toLoad.forEach(function (dataItem) {
    var headers = {},
      url = dataItem;
    if (_typeof(dataItem) === "object") {
      url = dataItem.url;
      headers = dataItem.headers;
    }
    parser = getParser(url);
    var request = parser(url);
    for (var _key in headers) {
      if ({}.hasOwnProperty.call(headers, _key)) {
        request.header(_key, headers[_key]);
      }
    }
    request.get(function (err, data) {
      data = err ? [] : data;
      if (data && !(data instanceof Array) && data.data && data.headers) data = fold(data);
      data = validateData(err, parser, data);
      loaded[getPathIndex(url, path)] = data;
      if (loadedLength(loaded) - alreadyLoaded === toLoad.length) {
        // All urls loaded

        // Format data
        data = loadedLength(loaded) === 1 ? loaded[0] : loaded;
        if (_this._cache) _this._lrucache.set("".concat(key, "_").concat(url), data);
        if (formatter) {
          var formatterResponse = formatter(loadedLength(loaded) === 1 ? loaded[0] : loaded);
          if (key === "data" && isObject(formatterResponse)) {
            data = formatterResponse.data || [];
            delete formatterResponse.data;
            _this.config(formatterResponse);
          } else data = formatterResponse || [];
        } else if (key === "data") {
          data = concat(loaded, "data");
        }
        if (key && "_".concat(key) in _this) _this["_".concat(key)] = data;
        if (callback) callback(err, data);
      }
    });
  });

  // If there is no data to Load response is immediately
  if (toLoad.length === 0) {
    loaded = loaded.map(function (data) {
      if (data && !(data instanceof Array) && data.data && data.headers) data = fold(data);
      return data;
    });

    // Format data
    var data = loadedLength(loaded) === 1 ? loaded[0] : loaded;
    if (formatter) {
      var formatterResponse = formatter(loadedLength(loaded) === 1 ? loaded[0] : loaded);
      if (key === "data" && isObject(formatterResponse)) {
        data = formatterResponse.data || [];
        delete formatterResponse.data;
        this.config(formatterResponse);
      } else data = formatterResponse || [];
    } else if (key === "data") {
      data = concat(loaded, "data");
    }
    if (key && "_".concat(key) in this) this["_".concat(key)] = data;
    if (callback) callback(null, data);
  }
}